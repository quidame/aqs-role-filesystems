---
# role: filesystems
# file: tasks/main.yml


################################################################################
# BACKWARD COMPATIBILITY
#
# Tasks to ensure bacward compatibility across versions, when changes occur in
# variable names or type/format.
#
#- import_tasks: backward-compatibility.yml


################################################################################
# CHECK POINT
#
# The check points are developped in a dedicated file. Their purpose is to fail
# as soon as possible in case one of the conditions (OS compatibility or type,
# format or value of mandatory variables) are unmet.
#
- import_tasks: checkpoint.yml


################################################################################
# NORMALIZATION
#
# Normalize /etc/fstab:
# - remove trailing slashes in directory paths
#   This will avoid duplicates, since when a record already exists for /foo/bar,
#   the mount module will create a new one for /foo/bar/ (or the opposite)
#   leaving the /foo/bar record after removal of the /foo/bar/'s one and THEIR
#   device !
#
- import_tasks: normalize-fstab.yml




################################################################################
################################################################################
# SERIAL OR SEQUENTIAL
#
# The sequential mode is more suitable for very complicated things (as long as
# there is no renaming between), and serial mode is faster. We play them in a
# block so we can share variables.
#
- name: "{{ filesystems__action }} filesystems"
  block:

    ############################################################################
    # sequential
    #
    #   Only one filesystem is set/unset at a time.
    #   - 1st filesystem: all tasks
    #   - 2nd filesystem: all tasks
    #   For example: fully setup a filesystem, then fully setup the next one...
    #
    - name: "{{ filesystems__action }} filesystems in sequential mode"
      when: "filesystems__behaviour == 'sequential'"
      include_tasks: "{{ filesystems__action }}.yml"
      loop: |
        [
          {% for d in __fslist_order__ %}
          [ {{ d }} ]{{ '' if loop.last else ',' }}
          {% endfor %}
        ]
      loop_control:
        loop_var: __fs__dictlist__
        label: { "path": "{{ __fs__dictlist__.0.path }}" }


    ############################################################################
    # serial
    #
    #   Each task is applied to all listed filesystems at once.
    #   - 1st task: all filesystems
    #   - 2nd task: all filesystems
    #   For example: create all LV, then create all FS, then mount all FS
    #
    - name: "{{ filesystems__action }} filesystems in serial mode"
      when: "filesystems__behaviour == 'serial'"
      include_tasks: "{{ filesystems__action }}.yml"
      vars:
        __fs__dictlist__: "{{ __fslist_order__ }}"


  # Block vars are set for all tasks of the block, and are available for the
  # more specific tasks vars.
  vars:
    # Normalize user input, i.e. fill missing but mandatory fields with default
    # values provisionned in filesystems__default_* variables. Also override
    # the 'path' by removing trailing slash and double slash. And append a key
    # derived from 2 others so we'll not have to do it later.
    filesystems__fslist_preprocess_0: |
      [
        {% for d in filesystems__fslist %}
        {% if filesystems__action in ['setup'] %}
        {% set D = {
          "vg": "%s" % (d.vg | d(filesystems__default_vg)),
          "size": "%s" % (d.size | d(filesystems__default_size)),
          "fstype": "%s" % (d.fstype | d(filesystems__default_fstype)),
          "path": "%s" % (d.path | regex_replace('/+$', '') | regex_replace('/+', '/')),
          "device": "/dev/mapper/%s-%s" % (d.vg | d(filesystems__default_vg) | replace('-','--'),
            d.lv | replace('-','--')),
          "force_lvol": d.force_lvol | d(d.force | d(filesystems__default_force_lvol)) | bool,
          "force_mkfs": d.force_mkfs | d(d.force | d(filesystems__default_force_mkfs)) | bool
          } %}
        {% elif filesystems__action in ['unset', 'umount'] %}
        {% set D = {
          "vg": "%s" % (d.vg | d(filesystems__default_vg)),
          "fstype": "%s" % (d.fstype | d(filesystems__default_fstype)),
          "path": "%s" % (d.path | regex_replace('/+$', '') | regex_replace('/+', '/')),
          "device": "/dev/mapper/%s-%s" % (d.vg | d(filesystems__default_vg) | replace('-','--'),
            d.lv | replace('-','--')),
          "force_lvol": d.force_lvol | d(d.force | d(filesystems__default_force_lvol)) | bool,
          "force_kill": d.force_kill | d(d.force | d(filesystems__default_force_kill)) | bool
          } %}
        {% endif %}
        {{ d | combine(D) }}{{ '' if loop.last else ',' }}
        {% endfor %}
      ]

    # Something else to do ? Maybe it's not a good idea to mix user input and
    # gathered facts (ansible_mounts, ansible_devices, ansible_lvm) so early.
    # But it makes sense to avoid common mistakes about LV and FS resizing...
    filesystems__fslist_preprocess_1: |
      [
        {% if filesystems__action in ['setup'] %}
        {% for d in filesystems__fslist_preprocess_0 %}
          {#
            # This will be to check if d.device has d.fstype filesystem type and
            # is mounted on d.path
          -#}
          {% set query_device = '[?mount == `%s`].device' % d.path %}
          {% set query_fstype = '[?mount == `%s`].fstype' % d.path %}
          {% set D = {} %}

          {#
            # ext4 can be extended when mounted or not; reduced when unmounted.
            # obviously, if the size string begins with a plus sign (+), there
            # is no need to worry about shrink parameter.
          -#}
          {% if d.fstype in ['ext4'] %}
            {% if d.size is match('\+') %}
            {% set D = { "resizefs": true } %}
            {% endif %}
            {% if d.device not in ansible_mounts | json_query('[*].device')
              and d.shrink is undefined
              and filesystems__default_shrink is undefined %}
              {#
                # if the device is not mounted, and 'shrink' is not defined at
                # all (neither for this fs nor as default), we simply set it to
                # the same value than 'force', that defaults itself to False.
              -#}
              {% set D = {
                "resizefs":  d.force_lvol | bool,
                "shrink": d.force_lvol | bool
                } %}
            {% endif %}

          {#
            # xfs can only be extended, and only if mounted; not shrinkable fs.
          -#}
          {% elif d.fstype in ['xfs'] %}
            {% set D = { "shrink": false } %}
            {% if [d.device] == ansible_mounts | json_query(query_device)
              and [d.fstype] == ansible_mounts | json_query(query_fstype)
              and d.resizefs is undefined
              and filesystems__default_resizefs is undefined %}
              {% set D = { "shrink": false, "resizefs": true } %}
            {% endif %}
          {% endif %}
        {{ d | combine(D) }}{{ '' if loop.last else ',' }}
        {% endfor %}
        {% endif %}
      ]

    filesystems__fslist_preprocessed: "{{
      filesystems__fslist_preprocess_0 if filesystems__action in ['unset', 'umount'] else
      filesystems__fslist_preprocess_1 if filesystems__action in ['setup'] else [] }}"

    # The list is sorted against the mountpoints to ensure nested mounts
    # are done in the right order and unmounted in reverse order.
    __fslist_setup__: "{{ filesystems__fslist_preprocessed | sort(attribute='path') }}"
    __fslist_unset__: "{{ filesystems__fslist_preprocessed | sort(attribute='path') | reverse | list }}"
    __fslist_order__: "{{ __fslist_setup__ if filesystems__action in ['setup'] else __fslist_unset__ }}"
