---
# role: filesystems
# file: tasks/checkpoint.yml


# This is intended to prevent late errors by catching common cases of failure.
# 1. OS compatibility
# 2. Mandatory parameters and their expected types, formats or values
# 3. Internal variables that MUST NOT be overridden from commandline and MUST
#    NOT conflict with inherited loop_var from another role, etc.
#
- name: "role assertions - do not bypass !"
  block:
    - name: "(python2) preset role assertions"
      set_fact:
        filesystems__role_assertions_for_python2: "{{ filesystems__role_assertions }}"
      tags:
        - "{{ 'never' if ansible_playbook_python | basename is match('python3') else 'always' }}"

    - name: "check point : role prerequisites and requirements"
      assert:
        that: "{{ filesystems__role_assertions | d(filesystems__role_assertions_for_python2) }}"

  vars:
    filesystems__role_assertions: |
      [
        {# Check OS compatibility and ansible version (should match meta/) -#}
        "( ansible_os_family in ['Debian'] and ansible_distribution_version is version('9.0', '>=') ) or \
         ( ansible_os_family in ['RedHat'] and ansible_distribution_version is version('7.0', '>=') )",
        "ansible_version.full is version('2.7', '>=')",

        {# Check value (keyword) of role variables controlling its behaviour -#}
        "filesystems__action in ['setup', 'unset', 'umount']",
        "filesystems__behaviour in ['serial', 'sequential']",

        {# check type of mandatory variables filled by user -#}
        "filesystems__fslist | type_debug == 'list'",
        "filesystems__parents | type_debug == 'dict'",

        {# Some variables are set and used internally and MUST NOT be overridden
           from commmandline. Also note that by checking they are undefined, we
           assume that they're left undefined after the role play, otherwise the
           role could not be played twice or more in the same playbook. So, the
           following variables must not be set in set_fact nor in register. -#}

        {# 1. Variable set either in task vars or in loop_var, depending on the
              filesystems__behaviour value. -#}
        "__fs__dictlist__ is undefined",

        {# 2. Variables set in task vars -#}
        "filesystems__fslist_preprocess_0 is undefined",
        "filesystems__fslist_preprocess_1 is undefined",
        "filesystems__fslist_preprocessed is undefined",
        "__tempvar0__ is undefined",
        "__tempvar1__ is undefined",
        "__tempvar2__ is undefined",
        "__mountpoints__ is undefined",
        "__fslist_setup__ is undefined",
        "__fslist_unset__ is undefined",
        "__fslist_order__ is undefined",
        "fstab_dicts is undefined",
        "fstab_devicelinks is undefined",
        "fstab_filesystems is undefined",
        "fstab_mountpoints is undefined",
        "fstab_assertions is undefined",
        "fstab_assertions_for_python2 is undefined or ansible_playbook_python | basename is not match('python3')",
        "renaming_assertions is undefined",
        "renaming_assertions_for_python2 is undefined or ansible_playbook_python | basename is not match('python3')",
        "filesystems__role_assertions is undefined",
        "filesystems__role_assertions_for_python2 is undefined or ansible_playbook_python | basename is not match('python3')",

        {# 3. Variables set in loop_var -#}
        "_fs_item is undefined",
        "_fs_parents_item is undefined",
        "_fs_rename_item is undefined",
        "fstab_item is undefined",

        {% set _fs_ = 'filesystems__fslist' %}
        {# Check mandatory variables and their format/type for all dicts of the
           list. By looping over the index (i) we can evaluate and display the
           symbolic path of the variable instead of its content (the dictionary
           itself), keeping assertions readable in case of error. A failed
           assertion will be displayed as (for example)
           "assertion": "filesystems__fslist.0.path is regex('^(/+[^/]+){2,}$')",
           "evaluated_to": false
           -#}
        {% for i in range(0, filesystems__fslist | length - 1) %}

        "{{ _fs_ }}.{{ i }} | type_debug == 'dict'",

        "{{ _fs_ }}.{{ i }}.path is defined",
        {# No first level directory, supports trailing / or consecutive /, since
           this will be normalized before doing anything - except overwrite the
           file /etc/fstab, that will be done first for the same reason -#}
        "{{ _fs_ }}.{{ i }}.path is regex('^(/+[^/]+){2,}$')",

        {% set canonic_path = filesystems__fslist[i].path | regex_replace('/+', '/') | regex_replace('/$', '') %}
        "{{ _fs_ }}.{{ i }}.lv is defined or \
        '{{ canonic_path }}' in ansible_mounts | json_query('[*].mount')",
        {# This is the LV name, not the path of the device (nor a symlink to
           it). We accept everything is supported by LVM. Dashes (-), that need
           to be translated to double-dashes (--) to match the device-mapper
           naming format, are supported too, as in (with lv='lv-foo-bar')
           /dev/vg-00/lv-foo-bar  <==>  /dev/mapper/vg--00-lv--foo--bar -#}
        "{{ _fs_ }}.{{ i }}.lv is regex('^[^/]+$')",

        "{{ _fs_ }}.{{ i }}.vg is undefined or {{ _fs_ }}.{{ i }}.vg in ansible_lvm.vgs", {# The VG exists -#}
        "{{ _fs_ }}.{{ i }}.vg is defined or filesystems__default_vg in ansible_lvm.vgs",

        {# The filesystem type, the volume size or the mount options don't
           matter when removing all this. So it could be nice to perform a
           triage here. Unfortunately, for whatever reason, jinja2 {% if %}
           {% endif %} blocks are silently ignored.
        -#}
        {# Accepted size formats:
          - Amounts are integers
          - Absolute units are k, m, g and t, case insensitive:
            1k = 1K = 1024 bytes (B)
            1m = 1M = 1024K
            ...
          - Percent units are relative to VG size (%VG) and VG free size
            (%FREE).
          - With percent units, amounts are in the range 1-100.
          - All above formats can be prefixed by either +, - or nothing.
        -#}
        "{{ _fs_ }}.{{ i }}.size is undefined or \
         {{ _fs_ }}.{{ i }}.size is regex('^[+-]?([1-9][0-9]*[BkKmMgGtT]|([1-9][0-9]?|100)%(VG|FREE|PVS))$')",
        "{{ _fs_ }}.{{ i }}.size is defined or \
         filesystems__default_size is regex('^[+-]?([1-9][0-9]*[BkKmMgGtT]|([1-9][0-9]?|100)%(VG|FREE|PVS))$')",

        "{{ _fs_ }}.{{ i }}.fstype is undefined or {{ _fs_ }}.{{ i }}.fstype in ['ext4', 'xfs']",
        "{{ _fs_ }}.{{ i }}.fstype is defined or filesystems__default_fstype in ['ext4', 'xfs']",

        {# XFS filsystem type is not shrinkable -#}
        "{{ _fs_ }}.{{ i }}.fstype | d(filesystems__default_fstype) != 'xfs' or \
         {{ _fs_ }}.{{ i }}.size | d(filesystems__default_size) is not match('-')",

        {# Exhaustivity is not a goal on its own. This is just a kind of example
           of checking optional parameters. Think if you really want to check
           permission values in octal as well as litteral formats for every case
           encountered... -#}
        "{{ _fs_ }}.{{ i }}.passno is undefined or {{ _fs_ }}.{{ i }}.passno in [0, 2, '0', '2']",
        "{{ _fs_ }}.{{ i }}.passno is defined or filesystems__default_passno | d(0) in [0, 2, '0', '2']",

        {# placeholder (to not worry about commas above); these two syntaxes
           (filesystems__fslist.0 or filesystems__list[0]) are equivalent. -#}
        "{{ _fs_ }}.{{ i }} == {{ _fs_ }}[{{ i }}]"{{ '' if loop.last else ',' }}

        {% endfor %}
      ]
