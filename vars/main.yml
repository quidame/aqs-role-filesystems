---
# role: filesystems
# file: vars/main.yml
#
# Variables defined here can't be overridden from anywhere, as this file has
# a high precedence/priority/weight.  You probably want to let it empty.
#
# These variables, if any, must follow the same naming rules than defined in
# defaults/main.yml.


################################################################################
## filesystems__behaviour
#
# This is also a behavioural variable that defines HOW the role will work.
# If 'serial' (the default), filesystems will be processed in parallel, i.e.
# all LV will be created, then all FS, then all mounts and so on. This mode is
# the most efficient.
# If 'sequential', filesystems will be processed sequentially, i.e. all tasks
# will be performed to setup/unset a filesystem, then all tasks for the next
# filesystem and so on.
#
filesystems__behaviour: "serial"


################################################################################
## filesystems__update_paths
#
# When set to True, this variable allows one to update paths of Logical Volumes
# or their mountpoints if for an active mount, one (and only one) of the LV name
# or directory path has changed in filesystems__fslist. This feature needs to
# unmount the filesystem before renaming it or the mountpoint, so processes
# accessing the fs must be stopped before.
#
filesystems__update_paths: True


################################################################################
## filesystems__validate
#
# When this variable is set to True, the role performs a validation of fstab
# before ending. Defaults to True.
#
filesystems__validate: True


################################################################################
## filesystems__units
#
# Dictionary of size units. Note that even if vgs, pvs and lvs commands make use
# of case sensitive units (vg_extent_size = 4194304B = 4096.00k = 4.00m = 4.19M
# = 4194.30K), lvcreate (called by ansible's lvol) and lvresize do not.
#
filesystems__units:
  B: "{{ 1024 | pow(0) | int }}"
  k: "{{ 1024 | pow(1) | int }}"
  K: "{{ 1024 | pow(1) | int }}"
  m: "{{ 1024 | pow(2) | int }}"
  M: "{{ 1024 | pow(2) | int }}"
  g: "{{ 1024 | pow(3) | int }}"
  G: "{{ 1024 | pow(3) | int }}"
  t: "{{ 1024 | pow(4) | int }}"
  T: "{{ 1024 | pow(4) | int }}"


#
# Preset all assertions here.
#

################################################################ ROLE ASSERTIONS
#
filesystems__role_assertions: |
  [
    {# Check OS compatibility and ansible version (should match meta/) -#}
    "( ansible_os_family in ['Debian'] and ansible_distribution_version is version('9.0', '>=') ) or \
     ( ansible_os_family in ['RedHat'] and ansible_distribution_version is version('7.0', '>=') )",
    "ansible_version.full is version('2.7', '>=')",

    {# Check value (keyword) of role variables controlling its behaviour -#}
    "filesystems__action in ['setup', 'unset', 'umount']",
    "filesystems__behaviour in ['serial', 'sequential']",

    {# Check type of mandatory variables filled by user -#}
    "filesystems__fslist | type_debug == 'list'",
    "filesystems__parents | type_debug == 'dict'",

    {# Check system internal consistency - See RATIONALE above -#}
    "filesystems__out_of_sync == []",

    {# Some variables are set and used internally and MUST NOT be overridden
       from commmandline. Also note that by checking they are undefined, we
       assume that they're left undefined after the role play, otherwise the
       role could not be played twice or more in the same playbook. So, the
       following variables must not be set in set_fact nor in register. -#}

    {# 1. Variable set either in task vars or in loop_var, depending on the
          filesystems__behaviour value. -#}
    "__fs__dictlist__ is undefined",

    {# 2. Variables set in task vars -#}
    "filesystems__fslist_preprocess_0 is undefined",
    "filesystems__fslist_preprocess_1 is undefined",
    "filesystems__fslist_preprocessed is undefined",
    "__tempvar0__ is undefined",
    "__tempvar1__ is undefined",
    "__tempvar2__ is undefined",
    "__mountpoints__ is undefined",
    "__fslist_setup__ is undefined",
    "__fslist_unset__ is undefined",
    "__fslist_order__ is undefined",
    "fstab_dicts is undefined",
    "fstab_devicelinks is undefined",
    "fstab_filesystems is undefined",
    "fstab_mountpoints is undefined",

    {# 3. Variables set in loop_var -#}
    "_fs_item is undefined",
    "_fs_parents_item is undefined",
    "_fs_rename_item is undefined",
    "fstab_item is undefined",

    {% set _fs_ = 'filesystems__fslist' %}
    {# Check mandatory variables and their format/type for all dicts of the
       list. By looping over the index (i) we can evaluate and display the
       symbolic path of the variable instead of its content (the dictionary
       itself), keeping assertions readable in case of error. A failed
       assertion will be displayed as (for example)
       "assertion": "filesystems__fslist.0.path is regex('^(/+[^/]+){2,}$')",
       "evaluated_to": false
       -#}
    {% for i in range(0, filesystems__fslist | length - 1) %}

    "{{ _fs_ }}.{{ i }} | type_debug == 'dict'",

    "{{ _fs_ }}.{{ i }}.path is defined",
    {# No first level directory, supports trailing / or consecutive /, since
       this will be normalized before doing anything - except overwrite the
       file /etc/fstab, that will be done first for the same reason -#}
    "{{ _fs_ }}.{{ i }}.path is regex('^(/+[^/]+){2,}$')",

    {% set canonic_path = filesystems__fslist[i].path | regex_replace('/+', '/') | regex_replace('/$', '') %}

    "{{ _fs_ }}.{{ i }}.lv is defined or \
    '{{ canonic_path }}' in ansible_mounts | json_query('[*].mount')",
    {# This is the LV name, not the path of the device (nor a symlink to
       it). We accept everything is supported by LVM. Dashes (-), that need
       to be translated to double-dashes (--) to match the device-mapper
       naming format, are supported too, as in (with lv='lv-foo-bar')
       /dev/vg-00/lv-foo-bar  <==>  /dev/mapper/vg--00-lv--foo--bar -#}
    "{{ _fs_ }}.{{ i }}.lv is regex('^[^/]+$')",

    "{{ _fs_ }}.{{ i }}.vg is undefined or {{ _fs_ }}.{{ i }}.vg in ansible_lvm.vgs", {# The VG exists -#}
    "{{ _fs_ }}.{{ i }}.vg is defined or filesystems__default_vg in ansible_lvm.vgs",

    {# The filesystem type, the volume size or the mount options don't
       matter when removing all this. So it could be nice to perform a
       triage here. Unfortunately, for whatever reason, jinja2 {% if %}
       {% endif %} blocks are silently ignored.
    -#}
    {# Accepted size formats:
      - Amounts are integers
      - Absolute units are k, m, g and t, case insensitive:
        1k = 1K = 1024 bytes (B)
        1m = 1M = 1024K
        ...
      - Percent units are relative to VG size (%VG) and VG free size
        (%FREE).
      - With percent units, amounts are in the range 1-100.
      - All above formats can be prefixed by either +, - or nothing.
    -#}
    "{{ _fs_ }}.{{ i }}.size is undefined or \
     {{ _fs_ }}.{{ i }}.size is regex('^[+-]?([1-9][0-9]*[BkKmMgGtT]|([1-9][0-9]?|100)%(VG|FREE|PVS))$')",
    "{{ _fs_ }}.{{ i }}.size is defined or \
     filesystems__default_size is regex('^[+-]?([1-9][0-9]*[BkKmMgGtT]|([1-9][0-9]?|100)%(VG|FREE|PVS))$')",

    "{{ _fs_ }}.{{ i }}.fstype is undefined or {{ _fs_ }}.{{ i }}.fstype in ['ext4', 'xfs']",
    "{{ _fs_ }}.{{ i }}.fstype is defined or filesystems__default_fstype in ['ext4', 'xfs']",

    {# XFS filsystem type is not shrinkable -#}
    "{{ _fs_ }}.{{ i }}.fstype | d(filesystems__default_fstype) != 'xfs' or \
     {{ _fs_ }}.{{ i }}.size | d(filesystems__default_size) is not match('-')",

    {# Exhaustivity is not a goal on its own. This is just a kind of example
       of checking optional parameters. Think if you really want to check
       permission values in octal as well as litteral formats for every case
       encountered... -#}
    "{{ _fs_ }}.{{ i }}.passno is undefined or {{ _fs_ }}.{{ i }}.passno in [0, 2, '0', '2']",
    "{{ _fs_ }}.{{ i }}.passno is defined or filesystems__default_passno | d(0) in [0, 2, '0', '2']",

    {# There is probably no chance to cleanly setup a new mountpoint if an
       existing one would be a subdirectory of the new one, i.e. if nested
       mounts are not set in the proper order.
       For example:
         /var/projects/apa_nna/apache_2.4 is an active mountpoint
         /var/projects is to be set as a mountpoint
       In this example, the mount on /var/projects will hide the one set on
       /var/projects/apa_nna/apache_2.4, and this is not what we want !!!
       This is aware of that and takes care to:
         - not fail if the wanted mount is active and action=setup
         - not fail if the mount is not set and action=unset
         - not fail if the mount is set, action=unset and submounts are listed
           to be unset too
    -#}
    {% set ismounted = canonic_path in ansible_mounts | json_query('[*].mount') %}
    {% set submounts = ansible_mounts
      | json_query('[*].mount')
      | map('regex_search', '^%s/.*' % canonic_path)
      | select('string')
      | list %}
    {% set sub_paths = filesystems__fslist
      | json_query('[*].path')
      | map('regex_replace', '/+', '/')
      | map('regex_replace', '/$', '')
      | map('regex_search', '^%s/.*' % canonic_path)
      | select('string')
      | list %}
    "( {{ submounts }} == [] ) or \
     ( filesystems__action in ['setup'] and {{ ismounted }} ) or \
     ( filesystems__action in ['unset', 'umount'] and {{ submounts | difference(sub_paths) }} == [] )",

    {# placeholder (to not worry about commas above); these two syntaxes
       (filesystems__fslist.0 or filesystems__list[0]) are equivalent. -#}
    "{{ _fs_ }}.{{ i }} == {{ _fs_ }}[{{ i }}]"{{ '' if loop.last else ',' }}

    {% endfor %}
  ]


############################################################### FSTAB ASSERTIONS
#
fstab_assertions: |
  [
    {###  1. Check for obvious/simple duplicates
    }#}
    "( fstab_mountpoints | sort ) == ( fstab_mountpoints | sort | unique )",
    "( fstab_filesystems | sort ) == ( fstab_filesystems | sort | unique )",

    {###  2. Check for hidden duplicated directories
            /foo/bar vs /foo/bar/
    }#}
    {% for x in fstab_mountpoints %}
    "'{{ x }}' in fstab_mountpoints and not '{{ x }}/' in fstab_mountpoints",
    {% endfor %}

    {###  3. Check for hidden duplicated devices
            /dev/VG/LV vs /dev/mapper/VG-LV
            Assert that if /dev/mapper/VG-LV is in the list, /dev/VG/LV is
            not.
    }#}
    {% for x in fstab_filesystems if x is match('/dev/mapper/') %}
    {% set X = '/dev/%s' % ( x | basename | regex_replace( '([^-])-([^-])', '\\1/\\2' ) | regex_replace( '--', '-' ) ) %}
    "'{{ x }}' in fstab_filesystems and not '{{ X }}' in fstab_filesystems",
    {% endfor %}

    {###  4. Check for unpredictable names
            /dev/sdb2, /dev/dm-7, /dev/xvda3, ...
            Unpredictable names are those of the block devices themselves,
            in /dev. Symlinks to them (and with predictable names) are all
            in subdirectories in /dev.
    }#}
    {% for x in fstab_devicelinks %}
    "'{{ x }}' is not match('/dev/[^/]+$')",
    {% endfor %}

    {###  5. Check for bad filesystem types
            This will verify that a fstype recorded in fstab matches the one
            in ansible_mounts for the same mountpoint. Since it is based on
            ansible_mounts, fstab entries that are not currently mounted are
            not checked. They will be in a next task by performing a real
            mount call. This test about fstype is done here because mount
            command will not raise an error with '-o remount'. So this piece
            of code and the mount of inactive mountpoints are complementary.
    }#}
    {% for x in fstab_dicts | product(ansible_mounts) if x.1.mount == x.0.mount | regex_replace('/+$', '') %}
    "'{{ x.1.mount }}' == '{{ x.0.mount | regex_replace('/+$', '') }}' and \
     '{{ x.1.fstype }}' == '{{ x.0.fstype }}'"{{ '' if loop.last else ',' }}
    {% endfor %}
  ]


############################################################ RENAMING ASSERTIONS
#
renaming_assertions: |
  [
    {% for i in range(0, _fs_rename_ | length) %}
    {% set s = __tempvar0__ | select('search', '^%s/' % _fs_rename_stat_.results[i]._fs_item.old.dir) | list %}
    "{{ __tempvar1__ | sort }} | intersect({{ s | sort }}) == {{ s | sort }}",

    {% if _fs_rename_[i].type == "dev" %}
    'not _fs_rename_stat_.results.{{ i }}.stat.exists'

    {% elif _fs_rename_[i].type == "dir" %}
    '( not _fs_rename_stat_.results.{{ i }}.stat.exists ) or \
     ( _fs_rename_stat_.results.{{ i }}.stat.isdir and _fs_rename_stat_.results.{{ i }}.stat.nlink == "2" )',
    '_fs_rename_stat_.results.{{ i }}._fs_item.target not in ansible_mounts | json_query("[*].mount")'
    {% endif %}{{ '' if loop.last else ',' }}
    {% endfor %}
  ]
